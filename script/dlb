#!/usr/bin/env bash

# Run a dlb script in the root of the working tree that contains the current directory.
#
# When called with a least one parameter that does not start with '-', the first such parameter must be a dlb script as
# a path relative to the root of the working tree. '.py' is appended if it does not end with '.py'.
# All parameters before are forwared the the Python interpreter.
# All parameters after are forwarded to the dlb script.
#
# When called without a parameter that does not start with '-', the parameters from the last successul call of dlb
# by this script are used.
#
# Each regular file or symbolic link in the directory '.dlbroot/u/' of the working tree whose name ends in '.zip'
# is added to the list of module search paths of the Python interpreter.
#
# Set the environment variable 'PYTHON' to the path of a Python interpreter to use an other interpreter than 'python3'.
#
# Example:
#
#    dlb build/all
#    dlb -v -Ximporttime build/all
#    dlb

PYTHON="${PYTHON:-python3}"

DLBROOT=.dlbroot
LAST="${DLBROOT:?}/last.bash"

set -e
shopt -s dotglob
shopt -s nullglob

# find root
last_cwd=''
while [ ! -d "./${DLBROOT:?}" ]; do
    last_cwd="$PWD"
    cd ..
    if [ "${last_cwd}" == "$PWD" ]; then
        printf "current working directory not in a dlb working tree (no '.dlbroot' found)\n" >&2
        exit 1
    fi
done

interpreter_arguments=()
while [ $# -gt 0 -a "${1:0:1}" == - ]; do
    interpreter_arguments+=("$1")
    shift
done

# collect script and script parameters
if [ $# -ge 1 ]; then
    script="$1"
    if [ -z "${script}" ] || [ "${script:0:1}" == / ]; then
        printf "not a script name: %q\n" "${script}" >&2
        exit 2
    fi
    script="${script%.py}.py"
    shift
    arguments=("${script:?}" "$@")
elif [ -f "./${LAST:?}" ]; then
    arguments=()
    while IFS=$'\n' read -r a; do  # do not allow code execution like 'source' would
        printf -v a %b "$a"
        arguments+=("$a")
    done < "./${LAST:?}"
    if [ ${#arguments[@]} -lt 1 ]; then
        printf "invalid dlb history file (remove it manually): %q\n" "./${LAST:?}" >&2
        exit 2
    fi
    printf -v argument_line ' %q' "${arguments[@]}"  # starts with ' '
    printf "use arguments of last successful run: %s\n" "${argument_line:1}" >&2
else
    printf "usage: %q [ <script-name> [ <script-parameter> ... ] ]\n" "${0##*/}" >&2
    exit 2
fi

# add .zip file in .dlbroot/u/ to PYTHONPATH
# paths in PYTHONPATH are separated by os.pathsep
# since this is Bash, assume os.pathsep to be ':'
paths=()
for zip_file in "${PWD}/.dlbroot/u/"?*.zip; do  # sorted
    if [ -f "${zip_file}" ]; then  # regular file or symbolic link to regular file?
        if [ "${zip_file%;*}" != "${zip_file}" ]; then
            printf "file path with separator cannot be used in PYTHONPATH: %q\n" "${zip_file}" >&2
            exit 1
        fi
        paths+=("${zip_file}")  # keep order of path name expansion
    fi
done
if [ ${#paths[@]} -gt 0 ]; then
    printf "add %d zip file(s) to PYTHONPATH\n" "${#paths[@]}"
    printf -v PYTHONPATH "%s;" "${paths[@]}" "${PYTHONPATH}"
    PYTHONPATH="${PYTHONPATH%;}"
    PYTHONPATH="${PYTHONPATH%;}"
    export PYTHONPATH
fi

# execute script
"${PYTHON:?}" "${interpreter_arguments[@]}" -- "${PWD}/${arguments[0]}" "${arguments[@]:1}"

# successful; write arguments (except interpreter arguments) to $LAST, suppressing error messages
(
    printf '' > "./${LAST:?}"
    for a in "${arguments[@]}"; do
        a="${a//\\/\\\\}"     # '\'   -> '\\'
        a="${a//$'\n'/\\n}"   # $'\n' -> '\t'
        printf "%s\n" "$a" >> "./${LAST:?}"
    done
) 2> /dev/null
